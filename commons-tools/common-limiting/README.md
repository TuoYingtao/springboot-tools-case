## 前言

最近几年，随着微服务的流行，服务和服务之间的依赖越来越强，调用关系越来越复杂，服务和服务之间的稳定性越来越重要。在遇到突发的请求量激增，恶意的用户访问，亦或请求频率过高给下游服务带来较大压力时，我们常常需要通过缓存、限流、熔断降级、负载均衡等多种方式保证服务的稳定性。其中限流是不可或缺的一环，这篇文章介绍限流相关知识。

## 什么是限流

**限流**顾名思义，就是对请求或并发数进行限制；通过对一个时间窗口内的请求量进行限制来保障系统的正常运行。如果我们的服务资源有限、处理能力有限，就需要对调用我们服务的上游请求进行限制，以防止自身服务由于资源耗尽而停止服务。

在限流中有两个概念需要了解：

- **阈值**：在一个单位时间内允许的请求量。如 QPS 限制为10，说明 1 秒内最多接受 10 次请求。
- **拒绝策略**：超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等待等。

> **限流和熔断有什么区别？**
>
> 限流发生在流量进来之前，超过的流量进行限制。
>
> 熔断是一种应对故障的机制，发生在流量进来之后，如果系统发生故障或者异常，熔断会自动切断请求，防止故障进一步扩展，导致服务雪崩。

> **限流和削峰有什么区别？**
>
> 削峰是对流量的平滑处理，通过缓慢地增加请求的处理速率来避免系统瞬时过载。
>
> 削峰大概就是水库，把流量储存起来，慢慢流，限流大概就是闸口，拒绝超出的流量。

## 限流的通用流程

那么具体限流怎么实现呢？可以概括为以下几个步骤：

![rate_limiter_execute.png](\docs\pic\rate_limiter_execute.png)

1. **统计请求流量**：记录请求的数量或速率，可以通过计数器、滑动窗口等方式进行统计。
2. **判断是否超过限制**：根据设定的限制条件，判断当前请求流量是否超过限制。
3. **执行限流策略**：如果请求流量超过限制，执行限流策略，如拒绝请求、延迟处理、返回错误信息等。
4. **更新统计信息**：根据请求的处理结果，更新统计信息，如增加计数器的值、更新滑动窗口的数据等。
5. **重复执行以上步骤**：不断地统计请求流量、判断是否超过限制、执行限流策略、更新统计信息

*当然具体的限流算法实现可能会根据不同的场景和需求进行调整和优化，比如使用令牌桶算法、漏桶算法等。*

## 单机限流与分布式限流

我们注意到，在限流的通用流程里，需要统计请求量、更新统计量，那么这个请求量的统计和更新就必须维护在一个存储里。假如只是一个单机版的环境，那就很好办了，直接储存到本地。但是一般来讲，我们的服务都是集群部署的，如何来实现多台机器之间整体的限流呢？

这时候就可以把我们的统计信息放到 Tair 或 Redis 等分布式的 K-V 存储中。

## 单机限流

### 固定窗口限流算法

**固定窗口算法**又叫**计数器算法**，是一种**简单**方便的限流算法。主要通过一个支持**原子操作**的计数器来累计 1 秒内的请求次数，当 1 秒内计数达到限流阈值时触发拒绝策略。每过 1 秒，计数器重置为 0 开始重新计数。